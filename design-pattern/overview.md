## 设计模式

https://github.com/ALEX-YRDM/design-patterns-in-java

**用一句话总结各种设计模式**

### 单例模式

确保一个类在全局运行范围内只存在一个实例，并对外提供统计获取该实例的接口

### 工厂模式

- 简单工厂：一个工厂类通过传入不同参数创建不同的产品对象，该类负责所有创建逻辑
- 工厂方法:  一类对象使用一个特定的工厂，每个工厂负责创建各自特定对象
- 抽象工厂：提供一个接口，用于创建某一系列产品族

### 建造者模式

分步骤构建复杂对象，并灵活生成不同版本 （个人理解：内部builder类可以链式通过.操作符构建，最终导出构建好的原对象）

### 原型模式

通过复制现有的对象来创建新对象，避免重复初始化（有浅拷贝和深拷贝两种）

### 适配器模式

客户端期望的接口不兼容，创建一个兼容的接口，在该接口内部调用现有的方法

### 组合模式

将对象组合成树状结构，使客户端可以以统一方式处理单个对象以及对象组合 （文件和文件夹）

### 代理模式

通过代理对象控制真实对象的访问，在不改变原有代码结构的基础上添加额外功能（AOP）

### 享元模式

池化思想

### 外观模式

为多个复杂子系统提供一个统一简化的高层接口

### 桥接模式

使抽象和实现分离，各自独立扩展而不相互影响 （数据库不同策略客户端 <---> 不同类型数据库）

### 装饰器模式

在不改变原始对象的前提下，动态为其添加额外功能

和代理模式区别：

- 装饰器：添加新能力，可以任意组合叠加
- 代理：访问控制，在原始调用方法前后添加一些函数

```
### **装饰器：你点了一杯咖啡，想加奶、加糖、加巧克力。**

咖啡 → 加糖 → 加奶 → 加巧克力
 （每层是一个 Decorator）

### **代理：你点咖啡，但必须通过服务员下单。**

服务员（代理） → 咖啡师（真实对象）
服务员会做权限检查、排队、记录日志，但不会改变咖啡本身。
```

### 模版方法模式

定义算法的固定步骤，允许子类重写其中部分步骤而不改变整体流程

### 中介者模式

通过引入中介对象封装对象间的交互，使得对象之间不会互相引用，降低耦合 （群聊消息，对象与对象之间传递）

### 责任链模式

将请求沿着一条对象链传递，每个对象可以选择处理请求或交给下一个处理者，实现发送者和处理者的解耦 （过滤器，拦截器）

### 观察者模式

当对象状态发生变化，自动通知所有依赖它的观察者，实现一对多动态关联和更新  （和发布订阅思想比较像

### 策略模式

将每一种可以更换的算法封装为独立策略，客户端可以自由选择而无需修改代码（支付方式：支付宝，微信，余额，银行卡...)

### 命令模式

将请求封装为对象，使调用者和接受者解耦，支持撤销，重做等操作 （编辑器，回退，重做）

### 状态模式

将对象在不同状态下的行为封装为独立状态类，使对象在运行时切换状态来改变行为 （游戏角色，满血，受伤，中毒，死亡...)

### 访问者模式

将数据结构与其操作分离，访问者对象在不修改被访问对象数据结构前提下为其添加新的功能 （一个数据结构，csv,json,txt,md导出）

### 迭代器模式

提供一种统一方式顺序访问聚合对象中的元素，无需暴露其内部结构

### 备忘录模式

不破坏对象封装的前提下，保存并恢复对象的历史状态（游戏存档）

### 解释器模式

为编程语言定义文法，通过解释器对象按规则解释句子 

（手搓python，js语言解释器，这一模式没有代码例子，但是本科时候用java写过简单的解释器 仓库地址https://github.com/ALEX-YRDM/FuncDrawing









